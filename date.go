package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
)

func main() {
	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "--help":
			fmt.Print(DateHelp())
			return
		}
	}
	fmt.Println(GetDate())
}

func DateHelp() string {
	return "Использование: date [ПАРАМЕТР]… [+ФОРМАТ]\n       или:    date [-u|--utc|--universal] [ММДДччмм[[ВВ]ГГ][.сс]]\nВыводит текущее время в заданном ФОРМАТЕ, или изменяет время в системе.\n\nАргументы, обязательные для длинных параметров, обязательны и для коротких.\n  -d,  --date=СТРОКА        показать не текущее время, а время, описанное\n                            заданной СТРОКОЙ\n      --debug               описывать разбираемую дату и предупреждать\n                            о сомнительном использовании в stderr\n  -f,  --file=ФАЙЛ          как --date для каждой строки из ФАЙЛА\n  -I[ФОРМ_ВРЕМЕНИ], --iso-8601[=ФОРМ_ВРЕМЕНИ]\n                            Вывод даты/времени в формате ISO 8601.\n                            Только дату, если ФОРМ_ВРЕМЕНИ=«date»\n                            (по умолчанию), «hours», «minutes», «seconds»\n                            или «ns» для получения даты и времени\n                            с нужной точностью.\n                            Пример: 2006-08-14T02:34:56-06:00\n  -R,  --rfc-email          выводить дату и время в соответствии с RFC-2822\n                            Пример: Mon, 14 Aug 2006 02:34:56 -0600\n       --rfc-3339=СПЕЦ      вывести дату/время в формате RFC 3339\n                            СПЕЦ=«date», «seconds» или «ns» для получения\n                            даты и времени с указанной точностью.\n                            Пример: 2006-08-14 02:34:56-06:00\n  -r,  --reference=ФАЙЛ     показать время последнего изменения ФАЙЛА\n  -s,  --set=СТРОКА         установить время, описанное СТРОКОЙ\n  -u, --utc, --universal    показать или установить универсальное\n                            координированное время (UTC)\n      --help     показать эту справку и выйти\n      --version  показать информацию о версии и выйти\n\n\nФОРМАТ управляет выводом. Воспринимаются следующие последовательности:\n\n  %%   знак %\n  %a   сокращённое название дня недели (напр., вск) согласно локали\n  %A   полное название дня недели (напр., понедельник) согласно локали\n  %b   сокращённое название месяца (напр., янв) согласно локали\n  %B   полное название месяца (напр., январь) согласно локали\n  %c   время и дата (напр., Чтв 3 Мар 23:05:25 2005) согласно локали\n  %C   век; как %Y, но не указываются две последние цифры (напр., 20)\n  %d   день месяца (напр., 01)\n  %D   дата; аналогично %m/%d/%y\n  %e   день месяца, дополненный пробелами; аналогично %_d\n  %F   полная дата; эквивалентно %+4Y-%m-%d\n  %g   последние две цифры года для номера недели ISO (см. %G)\n  %G   год для номера недели ISO (см. %V); обычно бывает полезно только с %V\n  %h   то же, что и %b\n  %H   час (00..23)\n  %I   час (01..12)\n  %j   номер дня в году (001..366)\n  %k   час, дополняется пробелом ( 0..23); тоже, что и %_H\n  %l   час, дополняется пробелом ( 1..12); тоже, что и %_I\n  %m   месяц (01..12)\n  %M   минуты (00..59)\n  %n   новая строка\n  %N   наносекунды (000000000..999999999)\n  %p   эквивалент AM или PM согласно локали; пусто если неизвестно\n  %P   как %p, но строчными буквами\n  %q   квартал (1..4)\n  %r   время согласно локали, 12-часовой формат (напр., 11:11:04 PM)\n  %R   часы и минуты согласно локали, 24-часовой формат; аналог %H:%M\n  %s   число секунд, истёкших с 1970-01-01 00:00:00 UTC\n  %S   секунды (00..60)\n  %t   табуляция\n  %T   время, аналог %H:%M:%S\n  %u   день недели (1..7); 1 обозначает понедельник\n  %U   номер недели в году, если первый день недели -- воскресенье (00..53)\n  %V   номер недели по ISO, если первый день недели -- понедельник (01..52)\n  %w   день недели (0..6), 0 означает воскресенье\n  %W   номер недели в году, если первый день недели -- понедельник (00..53)\n  %x   представление даты (напр., дд/мм/гг) согласно локали\n  %X   представление времени (напр.,  23:13:48) согласно локали\n  %y   последние две цифры года (00..99)\n  %Y   год\n  %z    +ччмм часового пояса (напр., -0400)\n  %:z   +чч:мм часового пояса (напр., -04:00)\n  %::z  +чч:мм:сс часового пояса (напр., -04:00:00)\n  %:::z часовой пояс с достаточным количеством двоеточий (напр., -04, +05:30)\n  %Z    буквенная аббревиатура часового пояса (напр., EDT)\n\nПо умолчанию date дополняет числовые поля нулями.\nПосле «%» могут идти следующие необязательные флаги:\n\n  - (дефис) не дополнять это поле\n  _ (подчёркивание) дополнять пробелами\n  0 (ноль) дополнять нулями\n  +  дополнять нулями и помещать «+» перед будущими годами >4 цифр\n  ^ использовать верхний регистр, если возможно\n  # использовать противоположный регистр, если возможно\n\nПосле любого из флагов идет необязательная ширина поля в виде десятичного числа;\nзатем необязательный модификатор, один из следующих:\nE -- если возможно, использовать альтернативное представление для текущей локали\nO -- если возможно, использовать альтернативные числовые символы локали.\n\nПримеры:\nПреобразовать значение в секундах с начала эпохи (1970-01-01 UTC) в дату\n  $ date --date='@2147483647'\n\nПоказать время на западном побережье США (см. tzselect(1) для поиска TZ)\n  $ TZ='America/Los_Angeles' date\n\nПоказать местное время 09:00 следующей пятницы на западном побережье США\n  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n\nСтраница справки по GNU coreutils: <https://www.gnu.org/software/coreutils/>\nОб ошибках в переводе сообщений сообщайте по адресу <https://translationproject.org/team/ru.html>\nПолная документация: <https://www.gnu.org/software/coreutils/date>\nили доступная локально: info '(coreutils) date invocation'\n"
}

func GetDate() string {
	cmd := exec.Command("date")
	stdout, err := cmd.Output()

	if err != nil {
		log.Fatal(err)

	}
	return string(stdout)
}
